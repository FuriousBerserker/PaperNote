### Brief Description of this work
1. GMRace is a hybrid data race detector for GPU programs. It targets data races in shared memory. GMRace consists of a static analyzer and a dynamic checker.
2. The static analyzer filters out race-free variables by checking whether the memory access can conflict with other memory accesses. The address of the memory access is parameterized by thread ID and loop iteration variable. Besides, the static analyzer also mark memory accesses if the associated addresses are invariant across threads or iterations.
3. The dynamic checker instruments the memory accesses to shared memory if static analyzer is unable to prove the addresses are race-free. It carries out intra-warp race detection and inter-warp race detection irrespectively.
4. For intra-warp race detection, GMRace records accessed addresses of all threads within the warp after executing an instruction. The data structure used to store memory accesses is called warpTable which is an array of size 32. If the instruction is a read, then the intra-warp race detection is skipped. Otherwise all threads scan the warpTable in parallel to see whether there exists two same addresses. After the intra-warp race detection, the warpTable is write to the global memory and recycled for next memory access.
5. GMRace executes inter-warp race detection periodically, which is carried out after each synchronization call. There are two modes for inter-warp race detection. GMRace-stmt organizes memory accesses in a BlockStmtTable according to the executed statements and the warp ID. The race detection algorithm is a 2-level nested for loop that compares the recorded memory addresses in any two rows. GMRace-stmt reports a race when there exists overlap between two rows belonging to different to warps and at least one of the row is a write operation. GMRace-stmt can report accurate diagnostic information about detected data races, but the time overhead is quadratic to the number of entries and the space overhead is linear to the number of entries, which is not scalable.
6. Another mode of inter-warp race detection is GMRace-flag, which compresses the information from warpTable to reduce the time and space overhead. For each warp, GMRace-flag allocates two tables, rWarpShmMap and wWarpShmMap, which are one-to-one mapping of shadow memory addresses. If the warp reads (writes) a memory location, the corresponding cell in the rWarpShmMap (wWarpShmMap) is set to 1. During the race detection, GMRace-flag counts the time of read and write operations for each memory location in the shadow memory, and report data races when there exist concurrent operations from different warps and at least one of them is a write operation. GMRace-flag's time and space complexity are linear to the size of shared memory, but it can only report conflict warp IDs and memory addresses.
7. For both GMRace-stmt and GMRace-flag, the data structures are reset after each synchronization call.
8. GMRace was implemented upon ROSE compiler.
### Contribution
1. An accurate race detector for GPU programs with low time and space overhead 
2. Leverage shared memory and all threads in the warp to accelerate data race detection
### Drawbacks
1. Can only tackle races in shadow memory, cannot tackle races in global memory and inter-block races (since there is no mechanism to synchronize threads across thread blocks, and inter-warp race detection resets the data structure after each check)
2. Only evaluate the performance for 5 benchmarks
3. Both GMRace-stmt and GMRace-flag cannot be applied to inter-block race detection since the memory overhead is enormous.
